# 1.线程
## 1.1 线程的状态
![[Pasted image 20220615160742.png]]
1、`新建/初始化状态（New）`：新创建了一个线程对象。
2、`就绪/可运行状态（Runnable）`：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。 
3、运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。 
4、`阻塞状态（Blocked）`：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种： 
	1)、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁) 
	2)、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。 
	3)、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁） 
5、`死亡状态（Dead）`：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。


## 1.2 线程与进程的关系
> 进程只是占内存
> 线程才小号CPU
> 默认一个进程至少一个线程
> 我们一般成为主进程和主线程



## 1.3 非守护线程与守护线程
### 非守护线程
非守护线程: 当主线程结束时,自己仍然在执行
在正常运行代码的时候， python是先执行主线程，执行完主线程后再调度其他线程
```python
import threading ,time
def start():
	time.sleep(2)
	print(threading.current_thread().name)
	print(threading.current_thread().isAlive())
	print(threading.current_thread().ident) # 当前线程的ID

if __name__ == "__main__":
	print("程序开始")
	t = threading.Thread(target = start, name = "我的第一个程序")
	t.start() # 开始执行线程
	print("程序结束")
```
以上代码执行结果是：
> 程序开始
> 程序结束
> 我的第一个线程
> True
> 9132

### 守护线程
守护线程是: 当主线程执行结束时,该守护线程就算没有执行完毕也会和主线程一起死.
阻塞线程是用t.join()方法，
```python
import threading ,time
def start():
	time.sleep(2)
	print(threading.current_thread().name)
	print(threading.current_thread().isAlive())
	print(threading.current_thread().ident) # 当前线程的ID

if __name__ == "__main__":
	print("程序开始")
	t = threading.Thread(target = start, name = "我的第一个程序")
	t.setDaemon(True)  # 启动守护线程, 主线程执行完毕,该线程一起死
	t.start() # 开始执行线程
	t.join() # 阻塞其他线程，让t线程先执行完毕
	print("程序结束")
```

以上代码执行结果是：
> 程序开始
> 我的第一个线程
> True
> 9132
   程序结束



# 全局解释器锁（GIL）
> 线程会先向系统申请GIL钥匙
> 拿到钥匙后，开锁进去
> 但GIL只允许一个线程进入（这里使用的是时分复用）
> 其他线程只能在外面等钥匙


```python
lock = threading.Lock()  # 普通锁 重量级锁
lock.acquire()  # 上锁
lock.release()  # 解锁
```