# 自旋锁
自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。

-   自旋锁：线程获取锁的时候，如果锁被其他线程持有，则当前线程将循环等待，直到获取到锁。
-   自旋锁等待期间，线程的状态不会改变，线程一直是用户态并且是活动的(active)。
-   自旋锁如果持有锁的时间太长，则会导致其它等待获取锁的线程耗尽CPU。
-   自旋锁本身无法保证公平性，同时也无法保证可重入性。
-   基于自旋锁，可以实现具备公平性和可重入性质的锁。

# 悲观锁
 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做==操作之前先上锁。==
**一般==多写==的场景下用悲观锁就比较合适。**

# 乐观锁
总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。**乐观锁适用于多读的应用类型，这样可以提高吞吐量**，像数据库提供的类似于**write_condition机制**，其实都是提供的乐观锁。
**乐观锁适用于==写比较少==的情况下（多读场景）**

# 读写锁
[读写锁](https://so.csdn.net/so/search?q=%E8%AF%BB%E5%86%99%E9%94%81&spm=1001.2101.3001.7020)其实还是一种锁，是给一段临界区代码加锁，但是此加锁是在进行写操作的时候才会互斥，而在进行读的时候是可以共享的进行访问临界区的  
ps：读写锁本质上是一种[自旋锁](https://so.csdn.net/so/search?q=%E8%87%AA%E6%97%8B%E9%94%81&spm=1001.2101.3001.7020)
